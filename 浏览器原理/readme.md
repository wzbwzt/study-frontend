# 事件循环/消息循环

> 1. js 是单线程的语言
> 2. 浏览器是多进程程序，js 运行在渲染主线程中

## 消息队列

- 微队列:优先级最高
- 交互队列:高于延迟消息队列
- 延迟消息队列
  ...

## 浏览器渲染原理

渲染进程中执行(沙盒)：

- 渲染主线程
- 合成线程

解析过程:
解析 html-> 样式计算 -> 布局(layout) -> 分层(layer) ->绘制（paint） -> 分块(tiling) -> 光栅化（Raster）-> 画（draw）

- 解析 html

  解析过程中遇到 css 解析 css,遇到 js 执行 js,为提供解析速度，开始解析前，会启动一个预解析的线程，率先下载 html 中的 link 外部 css/js;
  遇到 link 外部 css,不等待下载完成，继续解析, 因为下载和解析 css 的工作是在预解析线程中进行的，所以 css 不会阻塞 html 解析
  遇到 script 主线程停止解析 html，转而等待 js 下载完成，并将全局代码解析执行完成后，才能继续解析 html,因为 js 可能会修改当前的 dom 树，所以必须暂停解析

- 样式计算:
  得到一棵带有样式的 DOM 树;
  主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style;
  很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`;
  `css 属性值的计算过程`:层叠，继承
  `视觉格式化模型`:盒模型,包含块

- 布局:
  得到布局树;
  布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置;
  大部分时候，DOM 树和布局树并非一一对应: 比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。

  > 内容必须在行盒中;
  > 行盒和快盒不能相邻;

- 分层(layer)
  主线程会使用一套复杂的策略对整个布局树中进行分层。
  分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。
  滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

- 绘制（paint）
  主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。
  完成绘制后， 主线程工作完成，将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

- 分块(tiling)
  合成线程首先对每个图层进行分块，将其划分为更多的小区域。
  它会从线程池中拿取多个线程来完成分块工作。

- 光栅化（raster）
  合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。
  GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。
  光栅化的结果，就是一块一块的位图

- 画（draw）
  合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。
  指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。
  变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。
  合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。
